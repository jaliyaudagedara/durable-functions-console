@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="card shadow-sm @(_isFullScreen ? "fullscreen-card" : "")">
    <div class="card-header @HeaderClass">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">
                @if (!string.IsNullOrEmpty(Icon))
                {
                    <i class="bi bi-@Icon me-2"></i>
                }
                JSON
            </h5>
            <div class="d-flex gap-2">
                @AdditionalHeaderContent
                <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleFullScreen" title="@(_isFullScreen ? "Exit Full Screen" : "Full Screen")">
                    <i class="bi bi-@(_isFullScreen ? "fullscreen-exit" : "arrows-fullscreen")"></i>
                </button>
                @if (ShowCopyButton)
                {
                    <button class="btn btn-sm btn-outline-primary" @onclick="CopyToClipboard" disabled="@_isCopying">
                        <span class="bi bi-clipboard@(_copySuccess ? "-check" : "")"></span>
                        @(_isCopying ? "Copying..." : _copySuccess ? "Copied!" : "Copy")
                    </button>
                }
            </div>
        </div>
    </div>
    <div class="card-body p-0">
        <div @ref="_editorContainer" class="monaco-editor-container @(_isAnimating ? "editor-fade-in" : "")" style="@GetContainerStyle()"></div>
    </div>
</div>

<style>
    .monaco-editor-container {
        width: 100%;
        overflow: hidden;
        position: relative;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
    }

        .monaco-editor-container.editor-fade-in {
            opacity: 1;
        }

    .fullscreen-card {
        position: fixed !important;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999;
        margin: 0 !important;
        border-radius: 0 !important;
    }

        .fullscreen-card .monaco-editor-container {
            height: calc(100vh - 60px) !important;
            max-height: none !important;
        }

        .fullscreen-card .card-body {
            height: calc(100vh - 60px);
        }

    /* Smooth content update animation */
    @@keyframes contentUpdate {
        0% {
            opacity: 0.7;
            transform: translateY(2px);
        }

        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .monaco-editor-container.content-updating {
        animation: contentUpdate 0.3s ease-out;
    }
</style>

@code {
    [Parameter, EditorRequired] public string Content { get; set; } = string.Empty;
    [Parameter] public string Icon { get; set; } = "file-earmark-code";
    [Parameter] public string HeaderClass { get; set; } = "";
    [Parameter] public string LanguageClass { get; set; } = string.Empty;
    [Parameter] public bool ShowCopyButton { get; set; } = true;
    [Parameter] public string MaxHeight { get; set; } = "calc(100vh - 400px)";
    [Parameter] public string MinHeight { get; set; } = "300px";
    [Parameter] public RenderFragment? AdditionalHeaderContent { get; set; }
    [Parameter] public EventCallback<bool> OnCopyComplete { get; set; }

    private ElementReference _editorContainer;
    private IJSObjectReference? _jsModule;
    private bool _isCopying;
    private bool _copySuccess;
    private bool _isFullScreen;
    private string _lastContent = string.Empty;
    private bool _initialized;
    private bool _isAnimating;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/monacoEditor.js");
                await _jsModule.InvokeVoidAsync("initializeMonacoEditor", _editorContainer, Content);
                _lastContent = Content;
                _initialized = true;

                // Trigger fade-in animation
                _isAnimating = true;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing Monaco: {ex.Message}");
            }
        }
        else if (_initialized && _lastContent != Content)
        {
            try
            {
                // Trigger content update animation
                _isAnimating = false;
                StateHasChanged();
                await Task.Delay(10);

                await _jsModule!.InvokeVoidAsync("updateEditorContent", _editorContainer, Content);
                _lastContent = Content;

                _isAnimating = true;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error updating Monaco: {ex.Message}");
            }
        }
    }

    private async Task ToggleFullScreen()
    {
        _isFullScreen = !_isFullScreen;
        StateHasChanged();

        // Give the DOM time to update, then resize the Monaco editor
        await Task.Delay(50);

        if (_jsModule != null && _initialized)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("resizeEditor", _editorContainer);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error resizing Monaco: {ex.Message}");
            }
        }
    }

    private async Task CopyToClipboard()
    {
        if (string.IsNullOrEmpty(Content)) return;
        _isCopying = true;
        StateHasChanged();

        try
        {
            var success = await JSRuntime.InvokeAsync<bool>("clipboardInterop.copyToClipboard", Content);
            _copySuccess = success;
            if (success)
            {
                await OnCopyComplete.InvokeAsync(true);
                _ = Task.Delay(2000).ContinueWith(_ => { _copySuccess = false; InvokeAsync(StateHasChanged); });
            }
        }
        catch { _copySuccess = false; }
        finally { _isCopying = false; StateHasChanged(); }
    }

    private string GetContainerStyle()
    {
        if (_isFullScreen)
        {
            return "height: calc(100vh - 60px); max-height: none;";
        }
        return $"height: {(MaxHeight.Contains("calc") ? MaxHeight : MinHeight)}; max-height: {MaxHeight}; min-height: {MinHeight};";
    }

    public async ValueTask DisposeAsync()
    {
        _initialized = false;

        if (_jsModule != null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("disposeEditorSync", _editorContainer);
            }
            catch { }

            try
            {
                await _jsModule.DisposeAsync();
            }
            catch { }
        }
    }
}