@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="card shadow-sm @(_isFullScreen ? "fullscreen-card" : "")">
    <div class="card-header @HeaderClass">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">
                @if (!string.IsNullOrEmpty(Icon))
                {
                    <i class="bi bi-@Icon me-2"></i>
                }
                JSON
            </h5>
            <div class="d-flex gap-2">
                @AdditionalHeaderContent
                @if (_showReloadButton)
                {
                    <button class="btn btn-sm btn-outline-warning" @onclick="ReloadMonacoEditor" disabled="@_isReloading" title="Styles missing. Click to reload.">
                        <i class="bi bi-@(_isReloading ? "arrow-clockwise spin" : "exclamation-triangle") me-1"></i>
                        @(_isReloading ? "Reloading..." : "Fix Styles")
                    </button>
                }
                <button class="btn btn-sm @(_isFullScreen ? "btn-primary" : "btn-outline-secondary") fullscreen-toggle-btn"
                        @onclick="ToggleFullScreen"
                        title="@(_isFullScreen ? "Exit Full Screen (Esc)" : "Full Screen (F11)")">
                    <i class="bi bi-@(_isFullScreen ? "fullscreen-exit" : "arrows-fullscreen") me-1"></i>
                    @(_isFullScreen ? "Exit" : "Expand")
                </button>
                @if (ShowCopyButton)
                {
                    <button class="btn btn-sm btn-outline-primary" @onclick="CopyToClipboard" disabled="@_isCopying">
                        <span class="bi bi-clipboard@(_copySuccess ? "-check" : "")"></span>
                        @(_isCopying ? "Copying..." : _copySuccess ? "Copied!" : "Copy")
                    </button>
                }
            </div>
        </div>
    </div>
    <div class="card-body p-0">
        @if (_isInitializing)
        {
            <div class="monaco-loading-overlay" style="@GetContainerStyle()">
                <div class="spinner-border text-light" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="text-light mt-2">Loading JSON view...</p>
            </div>
        }
        <div @ref="_editorContainer" class="monaco-editor-container" style="@GetContainerStyle()"></div>
    </div>
</div>

<style>
    .monaco-editor-container {
        width: 100%;
        overflow: hidden;
        position: relative;
    }

    .monaco-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        background: #1e1e1e;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .fullscreen-card {
        position: fixed !important;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999;
        margin: 0 !important;
        border-radius: 0 !important;
    }

        .fullscreen-card .monaco-editor-container {
            height: calc(100vh - 60px) !important;
            max-height: none !important;
        }

        .fullscreen-card .card-body {
            height: calc(100vh - 60px);
        }

    .fullscreen-toggle-btn {
        font-weight: 500;
        min-width: 95px;
        transition: all 0.2s ease;
    }

        .fullscreen-toggle-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .fullscreen-toggle-btn i {
            font-size: 1.1em;
        }

    /* Enhanced visibility when in fullscreen mode */
    .fullscreen-card .fullscreen-toggle-btn {
        animation: pulse-subtle 2s ease-in-out infinite;
    }

    @@keyframes pulse-subtle {
        0%, 100% {
            box-shadow: 0 0 0 0 rgba(13, 110, 253, 0.4);
        }

        50% {
            box-shadow: 0 0 0 4px rgba(13, 110, 253, 0);
        }
    }

    .spin {
        animation: spin 1s linear infinite;
    }

    @@keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>

@code {
    [Parameter, EditorRequired] public string Content { get; set; } = string.Empty;
    [Parameter] public string Icon { get; set; } = "file-earmark-code";
    [Parameter] public string HeaderClass { get; set; } = "";
    [Parameter] public string LanguageClass { get; set; } = string.Empty;
    [Parameter] public bool ShowCopyButton { get; set; } = true;
    [Parameter] public string MaxHeight { get; set; } = "calc(100vh - 400px)";
    [Parameter] public string MinHeight { get; set; } = "300px";
    [Parameter] public RenderFragment? AdditionalHeaderContent { get; set; }
    [Parameter] public EventCallback<bool> OnCopyComplete { get; set; }

    private ElementReference _editorContainer;
    private IJSObjectReference? _jsModule;
    private bool _isCopying;
    private bool _copySuccess;
    private bool _isFullScreen;
    private string _lastContent = string.Empty;
    private bool _initialized;
    private bool _isInitializing;
    private bool _showReloadButton;
    private bool _isReloading;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            _isInitializing = true;
            StateHasChanged();

            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/monacoEditor.js");
                await _jsModule.InvokeVoidAsync("initializeMonacoEditor", _editorContainer, Content);
                _lastContent = Content;
                _initialized = true;

                // Check if Monaco CSS is missing and show reload button if needed
                await CheckMonacoStyles();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing Monaco: {ex.Message}");
                // Even on error, mark as initialized to prevent retry loops
                _initialized = true;
                _showReloadButton = true; // Show reload button on error
            }
            finally
            {
                _isInitializing = false;
                StateHasChanged();
            }
        }
        else if (_initialized && _lastContent != Content)
        {
            try
            {
                await _jsModule!.InvokeVoidAsync("updateEditorContent", _editorContainer, Content);
                _lastContent = Content;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error updating Monaco: {ex.Message}");
            }
        }
    }

    private async Task CheckMonacoStyles()
    {
        try
        {
            // Check if Monaco CSS is applied
            var hasStyles = await JSRuntime.InvokeAsync<bool>("eval",
                @"(() => {
                    const container = document.querySelector('.monaco-editor');
                    if (!container) return false;
                    const styles = window.getComputedStyle(container);
                    return styles.position === 'relative' || styles.overflow === 'hidden';
                })()");

            _showReloadButton = !hasStyles;

            if (_showReloadButton)
            {
                Console.WriteLine("Monaco CSS missing - showing reload button");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error checking Monaco styles: {ex.Message}");
            _showReloadButton = true;
        }
    }

    private async Task ToggleFullScreen()
    {
        _isFullScreen = !_isFullScreen;
        StateHasChanged();

        // Give the DOM time to update, then resize the Monaco editor
        await Task.Delay(50);

        if (_jsModule != null && _initialized)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("resizeEditor", _editorContainer);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error resizing Monaco: {ex.Message}");
            }
        }
    }

    private async Task CopyToClipboard()
    {
        if (string.IsNullOrEmpty(Content)) return;
        _isCopying = true;
        StateHasChanged();

        try
        {
            var success = await JSRuntime.InvokeAsync<bool>("clipboardInterop.copyToClipboard", Content);
            _copySuccess = success;
            if (success)
            {
                await OnCopyComplete.InvokeAsync(true);
                _ = Task.Delay(2000).ContinueWith(_ => { _copySuccess = false; InvokeAsync(StateHasChanged); });
            }
        }
        catch { _copySuccess = false; }
        finally { _isCopying = false; StateHasChanged(); }
    }

    private async Task ReloadMonacoEditor()
    {
        if (_isReloading || _jsModule == null)
            return;

        _isReloading = true;
        StateHasChanged();

        try
        {
            Console.WriteLine("Reloading Monaco editor...");

            // Dispose existing editor
            await _jsModule.InvokeVoidAsync("disposeEditorSync", _editorContainer);

            // Wait a moment
            await Task.Delay(200);

            // Reinitialize
            await _jsModule.InvokeVoidAsync("initializeMonacoEditor", _editorContainer, Content);

            // Check if it worked
            await Task.Delay(500);
            await CheckMonacoStyles();

            if (!_showReloadButton)
            {
                Console.WriteLine("Monaco editor reloaded successfully");
            }
            else
            {
                Console.WriteLine("Monaco editor still has issues after reload");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reloading Monaco: {ex.Message}");
            _showReloadButton = true;
        }
        finally
        {
            _isReloading = false;
            StateHasChanged();
        }
    }

    private string GetContainerStyle()
    {
        if (_isFullScreen)
        {
            return "height: calc(100vh - 60px); max-height: none;";
        }
        return $"height: {(MaxHeight.Contains("calc") ? MaxHeight : MinHeight)}; max-height: {MaxHeight}; min-height: {MinHeight};";
    }

    public async ValueTask DisposeAsync()
    {
        _initialized = false;

        if (_jsModule != null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("disposeEditorSync", _editorContainer);
            }
            catch { }

            try
            {
                await _jsModule.DisposeAsync();
            }
            catch { }
        }
    }
}